# 变量
## 变量类型：
- 整型 long 类型在win中为4字节，在linux中为8字节，一般使用long long类型

对应大小：
- 整型：4字节
- 浮点型：4字节
- 字符型：1字节
- 数组：元素大小 * 元素个数
- 指针：4字节（32位系统）或8字节（64位系统）
- 结构体：元素大小的总和
- 联合体：最大元素的大小
- 枚举：4字节
- 空类型：0字节

## 字符类型：(不能加入多个字符，否则会报错)
字符类型的本周是1字节，存储的是字符的ASCII码值，可以用整数给字符赋值，也可以用字符给字符赋值。
如：
``` cpp
char a='a';
int b=a;
cout<<b<<endl;
```
输出结果为97，即字符a的ASCII码值。

有一些字符的ASCII码值不是可见字符，如换行符、制表符等，这些字符不能直接输出，需要用转义字符来表示。
例如：
``` cpp
char a='\n';
cout<<a<<endl;
cout<<'\\'<<endl;//输出反斜杠,表示反斜杠本身
```
输出结果为换行符。


## signed 与 unsigned：(对数据的类型大小没有影响，影响的是数据的取值范围)
不改变整数的内存大小，但是改变了取值范围。
signed 整数的取值范围是 $[-2^{n-1}, 2^{n-1}-1]$，其中 $n$ 是整数的位数。
unsigned 整数的取值范围是 $[0, 2^n-1]$，其中 $n$ 是整数的位数。
char 类型是有符号的，取值范围是 $[-128, 127]$。
unsigned char 类型的取值范围是 $[0, 255]$。

## 浮点类型：
float ：4字节 有效数字位数6-7位
double ：8字节 有效数字位数15-16位

## 自动类型转换：
小的类型可以直接升级为大的类型：
char>>short>>int>>long int>>long long int

比较中的问题：
```cpp：
double a=1.0;
double b=0.1;
cout<<"a-b==0.9"<<endl;
```
十进制的0.1没办法直接用二进制表示，有误差

要比较的话使用fabs函数，判断两个数的差的绝对值是否小于一个很小的数。1e-9： 十亿分之一
```cpp：
double a=1.0;
double b=0.1;
cout<<"a-b==0.9"<<endl;
cout<<"fabs(a-b)<1e-9"<<endl;
```
输出结果为：
```
a-b==0.9
fabs(a-b)<1e-9
```
## 四舍五入
- 向上取整：ceil函数
- 向下取整：floor函数
- 四舍五入：round函数

## bool 逻辑：
早期的c ，bool类型是没有的，只能用int类型来表示。
c++ 中引入了bool类型，取值为true或false。使用一个字节来存储，true为1，false为0。意味着bool a=4 是true，bool b=0 是false。

如:输入一个年份：判断它是否为闰年。
hint：能被4整除，但是不能被100整除，或者能被400整除。
bool y=(year%4==0&&year%100!=0)||year%400==0;

## 交换变量
```cpp：
int a=1,b=2;
a=a^b;
b=a^b;
a=a^b;
cout<<"a="<<a<<endl;
cout<<"b="<<b<<endl;
```
输出结果为：
```
a=2
b=1
```
也可以使用宏定义函数来实现：
```cpp：
#define swap(a,b) a=a^b,b=a^b,a=a^b
```

## 指针：(大小之和)
指针本质上是一个整数，用来存储变量的内存地址。（虚拟地址）（对于32位系统来说占4字节，64位系统占8字节）
例如：
```cpp:
int main(){
    double a=12.5;
    double *p=&a;
    cout<<p<<endl;
    cout<<*p<<endl;
}
```
改变指针指向的变量：（ *p=100.0;）
```cpp：
int main(){
    double a=12.5;
    double *p=&a;
    cout<<p<<endl;
    cout<<*p<<endl;
    *p=100.0;
    cout<<p<<endl;
    cout<<*p<<endl;
}
```
输出结果为：
```
0x61fe18
12.5
0x61fe18
100.0
```

指针的类型：是指它指向的变量的类型。
如：
```cpp：
int a=12345;
unsigned char* p=(unsigned char*)&a;
```
p 是一个指向 int 类型变量的指针。
| 部分                       | 含义                                                    |
| ------------------------ | ----------------------------------------------------- |
| `&a`                     | 取变量 `a` 的内存地址，类型是 `int*`（假设 `a` 是 `int`）              |
| `(unsigned char*)`       | **强制类型转换**，把地址类型从 `int*` 转换成 `unsigned char*`，即“字节指针” |
| `unsigned char* p = ...` | 定义一个指针 `p`，它指向的是一个个字节（`unsigned char` 是 1 字节）         |

## 交换指针：
```cpp：
int main(){
    int a=12345;
    int b=54321;
    int *p1=&a;
    int *p2=&b;
    cout<<"p1="<<p1<<endl;
    cout<<"p2="<<p2<<endl;
    if(*p1>*p2)
        swap(*p1,*p2);
    cout<<"p1="<<p1<<endl;
    cout<<"p2="<<p2<<endl;
}
```

如果p是指针，p++？
p++ 是把指针 p 指向的内存地址往后移动 sizeof(int(不一定是int，取决于p指向的变量的类型)) 个字节，即指向变量 a 的下一个 int 类型变量。

## 函数：
调用步骤：（stack ： LIFO）
- 保存当前的执行断点，断点压栈
- 把函数的变参压栈，相当于创建了新的变量
- 跳转到函数的入口地址执行函数体
- 函数执行完毕后，弹出栈顶的断点，恢复到调用函数的位置
- 断点恢复，继续执行调用之后的语句。

形参的改变不影响实参，但是，当参数位指针类型是，会造成影响的假象。

意思是传输的是一个地址 *p，而不是变量 a 本身。
所以，在函数中改变 *p 的值，会影响到实参 a 的值。
但是p本身作为参数，它的值没有改变。

## 循环
while 循环：
```
while(条件){
    循环体;
}


do{
    循环体;
}while(条件);
```
for 循环：
```
for(初始化;条件;更新){
    循环体;
}
for(类型 变量: 容器){
    循环体;
}
```
## 数组和串
3种常见的变量类型：
- 局部变量：
在函数内部定义的变量，存储在栈区，函数调用结束后，变量被销毁。
- 全局变量：
在函数外部定义的变量，存储在全局区，程序运行期间一直存在，默认初始化为0。
- 堆变量：
通过new关键字动态分配的变量，存储在堆区，需要手动释放内存。

int* p=new int[3];  
delete[] p;不写的话会内存泄漏。

### 串：
串实际上就是字符数组，每个字符占用一个字节。我们规定它结尾处的char的值位0。

最后一定要在串的结尾处添加一个0，否则会导致输出错误。（'\0'）(空串也会分配一个char,占用一个字节)

例如：
```cpp:
int main(){
    char str[6]="hello";
    cout<<str<<endl;
}
```
字符串反转：
```cpp:
int main(){
    char s[100];cin>>s;
    char* p=s;
    while(*p!='\0') p++;
    p--;
    while(p>=s){
        cout<<*p;
        p--;
    }
    cout<<endl;
}
```


## 二维数组：
```
int a[3][4]={
    {1,2,3,4},
    {5,6,7,8},
    {9,10,11,12}
};
```
或者：
```cpp:
int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
```